# -*- coding: utf-8 -*-
"""RJRDY - 11372 - H9FR2 Financial Regulations CA1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wkmxEJ1EnlKm4PtahzobBE56-m51V-T0
"""

import openpyxl
from openpyxl.styles import Font
from openpyxl.worksheet.hyperlink import Hyperlink

def present_value_annuity(payment, rate, periods):
    """Calculate the present value of an ordinary annuity."""
    if rate == 0:
        return payment * periods
    else:
        return payment * (1 - (1 + rate) ** -periods) / rate

payment = 1000  # Fixed payment per period
rate = 0.05  # 5% annual interest rate
periods = 10  # 10 years

pv = present_value_annuity(payment, rate, periods)

wb = openpyxl.Workbook()
ws = wb.active
ws.title = "Annuity Calculation"

headers = ["Payment ($)", "Rate (%)", "Periods", "Present Value ($)"]
ws.append(headers)

for col in range(1, 5):
    ws.cell(row=1, column=col).font = Font(bold=True)

ws.append([payment, rate * 100, periods, round(pv, 2)])

colab_link = "https://colab.research.google.com/drive/YOUR_NOTEBOOK_ID"
ws.cell(row=3, column=1, value="Open Google Colab").hyperlink = colab_link
ws.cell(row=3, column=1).font = Font(color="0000FF", underline="single")

file_path = "/content/annuity_calculations.xlsx"
wb.save(file_path)

print(f"Excel file saved at: {file_path}")

def bond_price(face_value, coupon_rate, market_rate, years, payments_per_year):
    """Calculate bond price with periodic coupon payments."""
    coupon_payment = (coupon_rate / payments_per_year) * face_value
    discount_rate = market_rate / payments_per_year
    price = sum(coupon_payment / (1 + discount_rate) ** i for i in range(1, years * payments_per_year + 1))
    price += face_value / (1 + discount_rate) ** (years * payments_per_year)
    return round(price, 2)

# Example calculation
bond_price(face_value=1000, coupon_rate=0.05, market_rate=0.04, years=10, payments_per_year=2)

def bond_duration(face_value, coupon_rate, market_rate, years, payments_per_year):
    """Calculate Macaulay Duration of a bond."""
    coupon_payment = (coupon_rate / payments_per_year) * face_value
    discount_rate = market_rate / payments_per_year
    price = 0
    duration = 0

    for i in range(1, years * payments_per_year + 1):
        weight = i / payments_per_year
        price += coupon_payment / (1 + discount_rate) ** i
        duration += (weight * coupon_payment) / (1 + discount_rate) ** i

    weight = years
    price += face_value / (1 + discount_rate) ** (years * payments_per_year)
    duration += (weight * face_value) / (1 + discount_rate) ** (years * payments_per_year)

    return round(duration / price, 2)

# Example calculation
bond_duration(face_value=1000, coupon_rate=0.05, market_rate=0.04, years=10, payments_per_year=2)

def bond_price(yield_rate, face_value, coupon_rate, years, freq, market_price):
    """Compute bond price given a yield."""
    total_periods = years * freq
    coupon_payment = (coupon_rate * face_value) / freq
    price = sum([coupon_payment / (1 + yield_rate / freq) ** t for t in range(1, total_periods + 1)])
    price += face_value / (1 + yield_rate / freq) ** total_periods
    return price - market_price  # Difference from actual price (for root finding)

def bisection_ytm(face_value, coupon_rate, years, freq, market_price, tol=1e-6):
    """Use the Bisection Method to find YTM."""
    low, high = 0, 1  # Initial bounds for YTM (0% to 100%)

    while high - low > tol:
        mid = (low + high) / 2
        price_diff = bond_price(mid, face_value, coupon_rate, years, freq, market_price)

        if abs(price_diff) < tol:  # Root found
            return mid
        elif price_diff > 0:
            low = mid  # Yield is too low
        else:
            high = mid  # Yield is too high

    return (low + high) / 2  # Return approximate YTM

face_value = 1000      # Face value of the bond
coupon_rate = 0.05     # 5% annual coupon rate
years = 10             # Maturity in years
freq = 2              # Semi-annual coupon payments
market_price = 1081.76  # Market price of the bond

ytm = bisection_ytm(face_value, coupon_rate, years, freq, market_price)
print(f"Yield to Maturity (YTM): {ytm * 100:.4f}%")

import pandas as pd

def mortgage_payment(loan_amount, annual_rate, months):
    """Calculate fixed monthly mortgage payment."""
    monthly_rate = annual_rate / 12 / 100
    return loan_amount * monthly_rate / (1 - (1 + monthly_rate) ** -months)

def generate_amortization_schedule(loan_amount, annual_rate, term_years):
    """Generate mortgage amortization schedule."""
    months = term_years * 12
    monthly_payment = mortgage_payment(loan_amount, annual_rate, months)
    monthly_rate = annual_rate / 12 / 100
    schedule = []

    balance = loan_amount
    for i in range(1, months + 1):
        interest_paid = balance * monthly_rate
        principal_paid = monthly_payment - interest_paid
        balance -= principal_paid
        schedule.append([i, loan_amount, monthly_payment, interest_paid, principal_paid, balance])

    return pd.DataFrame(schedule, columns=["Month", "Beginning Balance", "Payment", "Interest Paid", "Principal Paid", "Ending Balance"])

loan_amount = 300000
annual_rate = 5
term_years = 30

df = generate_amortization_schedule(loan_amount, annual_rate, term_years)
print(df.head(12))  # Print first 12 months

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

stocks = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN", "META", "NVDA", "JPM", "NFLX", "BRK-B"]

import yfinance as yf
import pandas as pd

stocks = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN", "META", "NVDA", "JPM", "NFLX", "BRK-B"]

# Download data with auto_adjust=False to get "Adj Close"
data = yf.download(stocks, start="2023-03-01", end="2024-03-01", auto_adjust=False)

# Select the "Adj Close" column
adj_close = data["Adj Close"]
print(adj_close.head())

data = yf.download(stocks, start="2023-03-01", end="2024-03-01")

close_prices = data["Close"]
print(close_prices.head())

# Compute daily log returns
returns = np.log(data / data.shift(1))

# Drop NaN values from the first row
returns = returns.dropna()
returns.head()

# Compute the variance-covariance matrix
cov_matrix = returns.cov()
print("Variance-Covariance Matrix:\n", cov_matrix)

import yfinance as yf
import numpy as np
import pandas as pd

# Define stock tickers
stocks = ["AAPL", "MSFT", "TSLA", "GOOGL", "AMZN", "META", "NVDA", "JPM", "NFLX", "BRK-B"]

# Download stock price data
data = yf.download(stocks, start="2023-03-01", end="2024-03-01")["Close"]

# Compute daily log returns
returns = np.log(data / data.shift(1)).dropna()
print(returns.head())

# Compute the variance-covariance matrix
cov_matrix = returns.cov()
print(cov_matrix)

# Assign equal weights
n_assets = len(stocks)
weights = np.array([1/n_assets] * n_assets)

# Compute portfolio variance
portfolio_variance = np.dot(weights.T, np.dot(cov_matrix, weights))
portfolio_volatility = np.sqrt(portfolio_variance)

print(f"Portfolio Volatility: {portfolio_volatility}")

from scipy.stats import norm

# Calculate portfolio standard deviation for a single day
portfolio_std = np.sqrt(portfolio_variance)

# 10-day VaR at 99% confidence
z_score = norm.ppf(0.01)  # 1% level (left-tail)
VaR_10d = z_score * portfolio_std * np.sqrt(10)

print(f"10-Day VaR (99% confidence): {VaR_10d}")

# CVaR formula (expected loss beyond VaR threshold)
CVaR_10d = -(1 / (1 - 0.99)) * norm.pdf(z_score) * portfolio_std * np.sqrt(10)

print(f"10-Day CVaR (99% confidence): {CVaR_10d}")

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import norm

def hull_white_eso(S, K, T, r, sigma, vesting_period, early_exercise_factor):
    """
    Hull-White (2004) model for valuing Executive Stock Options (ESOs).

    Parameters:
    S : float  -> Current stock price
    K : float  -> Strike price
    T : float  -> Time to maturity (years)
    r : float  -> Risk-free interest rate (as decimal)
    sigma : float  -> Volatility of stock price (as decimal)
    vesting_period : float  -> Vesting period (years)
    early_exercise_factor : float  -> Factor to model early exercise behavior (0 to 1)

    Returns:
    ESO value (float)
    """

    # Adjusted time to maturity considering early exercise
    adjusted_T = max(T - vesting_period, 0) * early_exercise_factor

    # Compute d1 and d2 using Black-Scholes framework
    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * adjusted_T) / (sigma * np.sqrt(adjusted_T))
    d2 = d1 - sigma * np.sqrt(adjusted_T)

    # Compute ESO price (adjusting for vesting)
    ESO_value = (S * norm.cdf(d1) - K * np.exp(-r * adjusted_T) * norm.cdf(d2)) * np.exp(-r * vesting_period)

    return max(ESO_value, 0)  # Ensure non-negative option value

S = 100  # Current stock price
K = 100  # Strike price
T = 5    # Maturity in years
r = 0.03  # Risk-free rate
vesting_period = 2  # Vesting period in years
early_exercise_factor = 0.8  # Factor for early exercise behavior

volatility_values = np.linspace(0.1, 0.6, 50)
eso_values = [hull_white_eso(S, K, T, r, sigma, vesting_period, early_exercise_factor) for sigma in volatility_values]

plt.figure(figsize=(8,5))
plt.plot(volatility_values, eso_values, label="ESO Value vs Volatility")
plt.xlabel("Volatility (Ïƒ)")
plt.ylabel("ESO Value")
plt.title("Effect of Volatility on ESO Value (Hull-White Model)")
plt.legend()
plt.show()

sigma = 0.2  # Volatility (define this!)

risk_free_rates = np.linspace(0.01, 0.1, 50)  # Range of risk-free rates
eso_values_rf = [hull_white_eso(S, K, T, rf, sigma, vesting_period, early_exercise_factor) for rf in risk_free_rates]

plt.figure(figsize=(8,5))
plt.plot(risk_free_rates, eso_values_rf, label="ESO Value vs Risk-Free Rate", color="red")
plt.xlabel("Risk-Free Rate (r)")
plt.ylabel("ESO Value")
plt.title("Effect of Risk-Free Rate on ESO Value")
plt.legend()
plt.show()

early_exercise_factors = np.linspace(0.5, 1, 50)
eso_values_exercise = [hull_white_eso(S, K, T, r, sigma, vesting_period, e) for e in early_exercise_factors]

plt.figure(figsize=(8,5))
plt.plot(early_exercise_factors, eso_values_exercise, label="ESO Value vs Early Exercise Factor", color="purple")
plt.xlabel("Early Exercise Factor")
plt.ylabel("ESO Value")
plt.title("Effect of Early Exercise Behavior on ESO Value")
plt.legend()
plt.show()